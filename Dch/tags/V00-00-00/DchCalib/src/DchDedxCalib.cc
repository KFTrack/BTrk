//--------------------------------------------------------------------------
// File and Version Information:
// 	$Id: DchDedxCalib.cc 88 2010-01-14 12:32:57Z stroili $
//
// Description:
//	Class DchDedxCalib
//
// Environment:
//	Software developed for the BaBar Detector at the SLAC B-Factory.
//
// Author List:
//	Fergus Wilson           02-FEB-1999
//
// Changes:
//	Michael Kelsey 23-Feb-2005
//	   Add debugging messages.
//
//      Jean Roy     7-JAN-2000
//         Replace the multiple calibration functions by a simgle combined
//         function generated by DchDedxCorrFun.
//	
// Copyright Information:
//	Copyright (C) 1999	University of California, San Diego
//	Copyright (C) 2000	University of Colorado, Boulder
//
//------------------------------------------------------------------------
#include "BaBar/BaBar.hh"
#include <assert.h>
#include <math.h>
//
#include "CLHEP/Matrix/Vector.h"
#include "ErrLogger/ErrLog.hh"
//
#include "DchCalib/DchDedxCalib.hh"
#include "DchCalib/DchCalibFun.hh"

DchDedxCalib::DchDedxCalib(double globalGain,double gainFactor, const DchCalibFunRCPtr& cFun)
  : _globalGain(globalGain),_gainFactor(gainFactor*globalGain),_cFun(cFun),_iFun(0)
{
  if (_globalGain<= 0.0) { ErrMsg(fatal) << "invalid global gain " << _globalGain << endmsg;}
  if (_gainFactor <= 0.0) { ErrMsg(fatal) << "invalid gain " << _gainFactor << endmsg;}
  assert(_cFun->numberOfArguments()==5);

  if ( ErrLogging(debugging) ) {
    ErrMsg(debugging) << "DchDedxCalib::DchDedxCalib calib called with "
		      << " globalGain=" << globalGain << " WWLL gain factor "
		      << gainFactor << endmsg;
  }
}

DchDedxCalib::DchDedxCalib(const DchDedxCalib &rhs)
  :_globalGain(rhs._globalGain),
   _gainFactor(rhs._gainFactor),
   _cFun(rhs._cFun),
   _iFun(rhs._iFun.get()!=0?rhs._iFun->clone():0)
{ 
}

DchDedxCalib::~DchDedxCalib() 
{
}

double 
DchDedxCalib::dedx(double digiCharge, double path,  double doca,
               double entranceAngle, double dipAngle, double z,
               PdtPid::PidType hypo) const
{
  if (digiCharge<=0||path==0) {
     ErrMsg(warning) << "invalid digiCharge/dx: " << digiCharge << "/" << path << endmsg;
     return 0;
  }
  return calibratedCharge(digiCharge,doca,entranceAngle,
                          dipAngle,z ,hypo)/path;
}

double 
DchDedxCalib::calibratedCharge(double digiCharge, double doca,
               double entranceAngle, double dipAngle, double z,
               PdtPid::PidType hypo) const
{
  if (digiCharge<=0) {
     ErrMsg(warning) << "invalid digiCharge: " << digiCharge << endmsg;
     return 0;
  }
  // overall correction is a product of several functions
  static HepVector p(5);
  p[0] = digiCharge;
  p[1] = doca;
  p[2] = entranceAngle;
  p[3] = dipAngle;
  p[4] = z;

  digiCharge = _cFun->value(p);
  if (ErrLogging(debugging)) {		// Report calibration before GGG
    ErrMsg(debugging)
      << "DchDedxCalib::calibratedCharge converted raw charge " << p[0]
      << " to calibrated " << digiCharge << "\n and will divide that by"
      << " global gain factor " << _gainFactor << endmsg;
  }

  if (digiCharge<=0) {
    ErrMsg(warning) << "Invalid Corrected Charge " << digiCharge << endmsg;
    digiCharge=0;
  }

  // return calibrated charge value
  return digiCharge/_gainFactor;
}


double 
DchDedxCalib::rawCharge(double trueCharge, double doca,
                        double entranceAngle, double dipAngle,
                        double z, PdtPid::PidType hypo) const
{
  if (_iFun.get()==0) {
         _iFun.reset(_cFun->inverseFunction());
         if (_iFun.get()==0) {
            ErrMsg(fatal) << "cannot inverse calibrate charge..." << endmsg;
         }
  }
  if (trueCharge<=0) {
     ErrMsg(warning) << "invalid trueCharge: " << trueCharge << endmsg;
     return 0;
  }
  // overall correction is a product of several functions
  static HepVector p(5);
  p[0] = trueCharge*_gainFactor;
  p[1] = doca;
  p[2] = entranceAngle;
  p[3] = dipAngle;
  p[4] = z;
  return  _iFun->value(p);
}

double
DchDedxCalib::gainCorrection() const
{
  // return the factor used to compensate for the HV gain
  return double(1)/_gainFactor;
}

double
DchDedxCalib::globalGainCorrection() const
{
  // return the factor used to compensate for the HV gain
  return double(1)/_globalGain;
}


