// $id$
#ifndef DCHWIREARRAY_HH
#define DCHWIREARRAY_HH
#include "DchGeom/DchWireArrayBase.hh"

class DchDetector;
template <typename T> class DchWireArray;

// NOTE: all code independent of 'T' is in DchWireArrayIteratorBase to minimize
//       the amount of code generated by the compiler
template <typename T>
class DchWireArrayIterator : public DchWireArrayIteratorBase
{
public:
        typedef std::random_access_iterator_tag       iterator_category;
        typedef T                                     value_type;
        typedef value_type*                           pointer;
        typedef value_type&                           reference;

private:
        friend class DchWireArray<T>;
        DchWireArrayIterator(DchWireArray<T>& parent,unsigned l,unsigned w)
                :DchWireArrayIteratorBase(l,w),_parent(parent) {}
public:
        DchWireArrayIterator<T>& operator++() { inc(_parent); return *this;}
        DchWireArrayIterator<T>& operator--() { dec(_parent); return *this;}
        DchWireArrayIterator<T> operator++(int) { DchWireArrayIterator<T> x(*this);operator++();return x;}
        DchWireArrayIterator<T> operator--(int) { DchWireArrayIterator<T> x(*this);operator--();return x;}
        DchWireArrayIterator<T>& operator+=(int i) { return i<0?dec(_parent,-i):inc(_parent,i);}
        DchWireArrayIterator<T>& operator-=(int i) { return i<0?inc(_parent,-i):dec(_parent,i);}
        reference operator*() const  { return _parent(layer(),wire());}
        pointer operator->() const { return &(operator*());}
        bool operator==(const DchWireArrayIterator<T>& i) const { return eq(i);}
        bool operator> (const DchWireArrayIterator<T>& i) const { return gt(i);}
        bool operator!=(const DchWireArrayIterator<T>& i) const { return !operator==(i); }
        bool operator<=(const DchWireArrayIterator<T>& i) const { return !operator>(i);}
        bool operator< (const DchWireArrayIterator<T>& i) const { return operator<=(i) && !operator==(i);}
        bool operator>=(const DchWireArrayIterator<T>& i) const { return !operator<(i);}
private:
        DchWireArray<T>& _parent;
};


// NOTE: all code independent of 'T' is in DchWireArrayBase to minimize
//       the amount of code generated by the compiler, and to allow one
//       to copy the 'shape'
template <class T>
class DchWireArray : public DchWireArrayBase
{
public:
        typedef DchWireArrayIterator<T> iterator ;

        DchWireArray<T>(const DchDetector& det, const T& t = T())
                : DchWireArrayBase(det),_t(nWires(),t){}

        // copy shape, but not content from another array
        DchWireArray<T>(const DchWireArrayBase& o, const T& t )
                : DchWireArrayBase(o),_t(nWires(),t){}

        // copy constructor
        DchWireArray<T>(const DchWireArray<T>& o)
                : DchWireArrayBase(o),_t(o._t){}

        const T& at(unsigned layer, unsigned wire) const
        { return operator()(layer,wire); }

        T& at(unsigned layer, unsigned wire)
        { return operator()(layer,wire); }

        const T& operator()(unsigned layer, unsigned wire) const
        { return _t[index(layer,wire)]; }

        T& operator()(unsigned layer, unsigned wire)
        { return _t[index(layer,wire)]; }


        template <typename I>
        const T& at(const I& i) const
        { return at(i.layer(),i.wire()); }

        template <typename I>
        T& at(const I& i)
        { return at(i.layer(),i.wire()); }

        template <typename I>
        const T& operator()(const I& i) const
        { return operator()(i.layer(),i.wire()); }

        template <typename I>
        T& operator()(const I& i)
        { return operator()(i.layer(),i.wire()); }

        iterator begin(unsigned l) { return DchWireArrayIterator<T>(*this,l,firstWire(l));}
        iterator begin() { return begin(firstLayer());}

        iterator end() { unsigned l=lastLayer();return DchWireArrayIterator<T>(*this,l,lastWire(l)+1);}
        iterator end(unsigned l) { return l<lastLayer()?begin(l+1):end();}

        unsigned size() {return _t.size();}

private:
        std::vector<T>         _t;
};
#endif
