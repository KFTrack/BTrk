//--------------------------------------------------------------------------
// File and Version Information:
// 	$Id: DchHyperb.cc 123 2010-04-29 14:41:45Z stroili $
//
// Description:
//	Class DchHyperb
//
// Environment:
//	Software developed for the BaBar Detector at the SLAC B-Factory.
//
// Author List:
//	R. Stroili		originator
//	
//
// Copyright Information:
//	Copyright (C) 1996	INFN & Padova University
//
//------------------------------------------------------------------------
#include "BaBar/BaBar.hh"

//-----------------------
// This Class's Header --
//-----------------------
#include "DchGeom/DchHyperb.hh"

//-------------
// C Headers --
//-------------

//---------------
// C++ Headers --
//---------------
#include <assert.h>
#include <iostream>

//-------------------------------
// Collaborating Class Headers --
//-------------------------------
#include "BaBar/Constants.hh"
#include "ErrLogger/ErrLog.hh"
#include "CLHEP/Geometry/HepPoint.h"
#include "CLHEP/Geometry/Transformation.h"
#include "CLHEP/Vector/ThreeVector.h"
#include "DetectorModel/DetCylinder.hh"

//-----------------------------------------------------------------------
// Local Macros, Typedefs, Structures, Unions and Forward Declarations --
//-----------------------------------------------------------------------

static const char rscid[] =
    "$Id: DchHyperb.cc 123 2010-04-29 14:41:45Z stroili $";

//		----------------------------------------
// 		-- Public Function Member Definitions --
//		----------------------------------------

//----------------
// Constructors --
//----------------
DchHyperb::DchHyperb(const HepTransformation& transf, double a, double c,
    double zl, double twist) :
  DetSurface(transf), _parA(a), _parC(c), _zmax(zl * 0.5), _twist(twist)
{
  assert ( a != 0 );
  assert ( zl != 0 );
}

DchHyperb::DchHyperb(const HepTransformation& transf, double rend,
    double zlength, double twist) :
  DetSurface(transf), _zmax(zlength * 0.5), _twist(twist)
{
  double rmid = rend * cos(_twist * 0.5);
  _parA = 1. / rmid;
  _parC = sqrt(rend * rend / (rmid * rmid) - 1.) / fabs(_zmax);
}

//--------------
// Destructor --
//--------------
DchHyperb::~DchHyperb()
{
}
//
//   copyOf function
//
DetSurface*
DchHyperb::copyOf(double fparam) const
{
  if (fparam == 0.0) {
    return (DetSurface*) new DchHyperb(*this);
  } else {
    // assume that the family is generated by scaling the 2 
    // parameters by the same factor
    return (DetSurface*) new DchHyperb(*transform(), _parA / fparam,
        _zmax * 2., _twist);
  }
}
// 
// Member Functions
//
Hep3Vector
DchHyperb::normal(const SurfacePoint& uv) const
{
  //
  //  return normal to surface at given surface point
  //
  HepPoint p = spacePoint(uv);
  HepPoint l = gotoLocal(p);
  Hep3Vector n(2. * l.x() * (_parA * _parA), 2. * l.y() * (_parA * _parA), -2.
      * l.z() * (_parC * _parC));
  Hep3Vector g = gotoGlobal(n);
  return g.unit();
}

double
DchHyperb::normTo(const HepPoint& x, Hep3Vector& n) const
{
  const double _epsilon = 1.e-6;
  // transformation to local coordinate is done by |surfaceCoord|
  SurfacePoint uu;
  int isOnSurf = surfacePoint(x, uu);
  if (isOnSurf == 0) { // point is on surface, easy
    n = normal(uu);
    return 0.;
  }
  // numerical solution (for the moment) 
  //  
  HepPoint local = gotoLocal(x);
  //  double rad = sqrt(x.x()*x.x()+x.y()*x.y());
  double lrad = sqrt(local.x() * local.x() + local.y() * local.y());
  double distance, ref;
  double delta = 10000.;
  ref = fabs(lrad - radFromZ(local.z()));
  double incZ = 2.;
  double z0 = local.z();
  //  int count = 0;
  if ((lrad > radFromZ(local.z()) && local.z() < 0.) || (lrad < radFromZ(
      local.z()) && local.z() > 0.)) {
    incZ = -2.;
  }
  double zz = z0;
  while (fabs(delta) > _epsilon) {
    zz += incZ;
    distance = sqrt((lrad - radFromZ(zz)) * (lrad - radFromZ(zz)) + (local.z()
        - zz) * (local.z() - zz));
    delta = ref - distance;
    if (distance < ref) {
      ref = distance;
    } else {
      zz -= incZ;
      incZ = incZ / 2.;
    }
  }

  double radius = radFromZ(zz);
  double phi = atan2(x.y(), x.x());
  double xx = 0.;
  double yy = 0.;
  if (x.x() != 0.) {
    xx = x.x() * fabs(radius * cos(phi) / x.x());
  }
  if (x.y() != 0.) {
    yy = x.y() * fabs(radius * sin(phi) / x.y());
  }

  distance = 0.;

  HepPoint min(xx, yy, zz);
  int good = surfacePoint(gotoGlobal(min), uu);
  n = normal(uu);

  if (good == 0) {
    distance = min.distanceTo(local);
    // return a signed distance
    if (lrad != radius) {
      distance = fabs(distance) * (radius - lrad) / fabs(lrad - radius);
    }
  }

  return distance;
}

DetSurface::intertype
DchHyperb::distTo(const HepPoint& p, const Hep3Vector& dir, double& dist,
    intermode mode) const
{
  DetSurface::intertype retval = DetSurface::nointersect;

  HepPoint x = gotoLocal(p);
  Hep3Vector v = (gotoLocal(dir)).unit();

  double a = _parA * _parA * sin(v.theta()) * sin(v.theta()) - _parC * _parC
      * cos(v.theta()) * cos(v.theta());
  double b = (x.x() * cos(v.phi()) + x.y() * sin(v.phi())) * _parA * _parA
      * sin(v.theta()) - x.z() * cos(v.theta()) * _parC * _parC;
  double c = _parA * _parA * (x.x() * x.x() + x.y() * x.y()) - _parC * _parC
      * x.z() * x.z() - 1.0;

  double root1 = 0.;
  double root2 = 0.;

  double delta2 = b * b - a * c;

  if (delta2 < 0.0 || a == 0.0) {
    //
    //  approximate solution: find the POCA to the axis and then get the 
    //  radius of the hyperboloid at the z coordinate of the POCA.
    //  Return the difference between the found radius of the surface and the
    //  distance of the POCA from the axis
    //
    retval = DetSurface::localmin;

    if (sin(v.theta()) == 0.) return DetSurface::nointersect;

    double l = (x.x() * cos(v.phi()) + x.y() * sin(v.phi())) / sin(v.theta());

    double r1 = radFromZ(x.z() + l * cos(v.theta()));
    double x2 = l * sin(v.theta()) * cos(v.phi()) + x.x();
    double y2 = l * sin(v.theta()) * sin(v.phi()) + x.y();
    double r2 = sqrt(x2 * x2 + y2 * y2);

    dist = r1 - r2;

  } else {
    //
    //  found intersection of the trajectory (line) with the surface
    //
    root1 = (-b - sqrt(delta2)) / a;
    root2 = (-b + sqrt(delta2)) / a;
    if (root1 > root2) {
      double tmpd = root1;
      root1 = root2;
      root2 = tmpd;
    }
  }

  if (retval != DetSurface::localmin) {
    retval = DetSurface::intersect;
    switch (mode) {
    case closest:
      dist = fabs(root1) < fabs(root2) ? root1 : root2;
      break;
    case forward:
      dist = root1 > 0 ? root1 : root2;
      if (dist < 0.0) retval = DetSurface::outofrange;
      break;
    case backward:
      dist = root2 < 0 ? root2 : root1;
      if (dist > 0.0) retval = DetSurface::outofrange;
      break;
    }
  }

  if ((mode == forward && dist < 0.0) || (mode == backward && dist > 0.0)) retval
      = DetSurface::outofrange;

  return retval;
}

double
DchHyperb::firstDeriv(const HepPoint& thePoint, const Hep3Vector& theDirection) const
{
  Hep3Vector theNormal;
  normTo(thePoint, theNormal);
  return theDirection.unit() * theNormal;
}

HepPoint
DchHyperb::spacePoint(const SurfacePoint& uv) const
{
  double z = uv[1];
  double rad = radFromZ(z);
  double x = rad * cos(uv[0]);
  double y = rad * sin(uv[0]);

  return gotoGlobal(HepPoint(x, y, z));
}

void
DchHyperb::segmentMinMax(const HepPoint& pointOne, const HepPoint& pointTwo,
    double& mindist, double& maxdist) const
{
  // approximate surface to local cylinder with radius mid of the radii
  // determined by the 2 points and get cylinder response (untill
  // somebody will find a better solution)
  HepPoint loc1 = gotoLocal(pointOne);
  HepPoint loc2 = gotoLocal(pointTwo);
  double meanRad = .25 * sqrt(loc1.x() * loc1.x() + loc1.y() * loc1.y()
      + loc2.x() * loc2.x() + loc2.y() * loc2.y());
  DetCylinder localCyl(*transform(), meanRad);
  localCyl.segmentMinMax(pointOne, pointTwo, mindist, maxdist);
}

int
DchHyperb::surfacePoint(const HepPoint& thePoint, SurfacePoint& uv, double tol) const
{
  HepPoint theLocalPoint(gotoLocal(thePoint));
  uv[0] = theLocalPoint.phi();
  // ensure that phi is between 0 and 2pi
  if (uv[0] < 0) uv[0] += Constants::twoPi;
  uv[1] = theLocalPoint.z();

  double redz = uv[1] * _parC;
  double tphi = tan(uv[0]);
  double actualX = sqrt((1. + redz * redz) / ((_parA * _parA) + tphi * tphi
      * (_parA * _parA)));
  if (uv[0] > Constants::pi / 2. && uv[0] < 1.5 * Constants::pi) {
    actualX = -actualX;
  }
  if (fabs(actualX - theLocalPoint.x()) > tol) {
    return 1;
  }

  return 0;
}

Hep3Vector
DchHyperb::surfaceDirection(const SurfacePoint& uv, int idir) const
{
  double x = -sin(uv[0]);
  double y = cos(uv[0]);
  Hep3Vector tangent = gotoGlobal(Hep3Vector(x, y, 0.));

  switch (idir) {
  case 1:
    return tangent.cross(normal(uv));
  case 0:
  default:
    return tangent;
  }
}

bool
DchHyperb::wrappedCoordinate(int theCoordNumber) const
{
  //  the wrapped coordinate is case 0, case 1 is the coordinate 
  //  along the z axis, to be consistent with DetCylinder 
  switch (theCoordNumber) {
  case 0:
    return true;
  case 1:
  default:
    return false;
  }
}

double
DchHyperb::projectPhiToRear(const HepPoint& point) const
{
  //  in the BaBar reference frame
  SurfacePoint uu;
  int isOnSurf = surfacePoint(point, uu);
  if (isOnSurf != 0) { // point is not on surface always return -9999.
    ErrMsg(warning) << "point is not on surface" << endmsg;
    return -9999.;
  }
  double deltaphi = 0.5 * (1. + uu[1] / _zmax) * twist();
  uu[0] -= deltaphi;
  uu[1] = -_zmax;

  HepPoint rearProjection = spacePoint(uu);

  return rearProjection.phi();
}

double
DchHyperb::curvature(const SurfacePoint& uv) const
{
  return _parA / (sqrt(1. + uv[0] * uv[0] * (_parC * _parC)));
}

